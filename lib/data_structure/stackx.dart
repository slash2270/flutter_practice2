// @dart = 2.9

class StackX {

  final int size = 20;
  List<int> st;
  int top = -1;

  StackX(){
    st = List.filled(size, 0);
  }

  void push(int j){
    st[++top] = j;
  }

  int pop(){
    return st[top--];
  }

  int peek(){
    return st[top];
  }

  bool isEmpty(){
    return (top == -1);
  }

}

/*
②、邊：
在前面講解各種樹的資料結構時，大多數樹都是每個節點包含它的子節點的參照，比如紅黑樹、二元樹。也有用陣列表示樹，樹組中節點的位置決定了它和其它節點的關係，比如堆就是用陣列表示。
然而圖並不像樹，圖沒有固定的結構，圖的每個頂點可以與任意多個頂點相連，為了模擬這種自由形式的組織結構，用如下兩種方式表示圖：鄰接矩陣和鄰接表（如果一條邊連線兩個頂點，那麼這兩個頂點就是鄰接的）

鄰接矩陣：
鄰接矩陣是一個二維陣列，資料項表示兩點間是否存在邊，如果圖中有 N 個頂點，鄰接矩陣就是 N*N 的陣列。上圖用鄰接矩陣表示如下：　　

1表示有邊，0表示沒有邊，也可以用布林變數true和false來表示。頂點與自身相連用 0 表示，所以這個矩陣從左上角到右上角的對角線全是 0 。
注意：這個矩陣的上三角是下三角的映象，兩個三角包含了相同的資訊，這個冗餘資訊看似低效，但是在大多數計算機中，創造一個三角形陣列比較困難，所以只好接受這個冗餘，這也要求在程式處理中，
當我們增加一條邊時，比如更新鄰接矩陣的兩部分，而不是一部分。
鄰接表：
鄰接表是一個連結串列陣列（或者是連結串列的連結串列），每個單獨的連結串列表示了有哪些頂點與當前頂點鄰接。
 */