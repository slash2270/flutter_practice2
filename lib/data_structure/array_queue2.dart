// @dart = 2.9

class ArrayQueue2 {

  final int size = 20;
  List<int> queArray;
  int front = 0;
  int rear = -1;

  ArrayQueue2(){
    queArray = List.generate(size, (index) => 0);
  }

  void insert(int j) {
    if(rear == size - 1) {
      rear = -1;
    }
    queArray[++rear] = j;
  }

  int remove() {
    int temp = queArray[front++];
    if(front == size) {
      front = 0;
    }
    return temp;
  }

  bool isEmpty() {
    return (rear + 1 == front || front + size - 1 == rear);
  }

}

/*
3、搜尋
在圖中實現最基本的操作之一就是搜尋從一個指定頂點可以到達哪些頂點，比如從武漢出發的高鐵可以到達哪些城市，一些城市可以直達，一些城市不能直達。
現在有一份全國高鐵模擬圖，要從某個城市（頂點）開始，
沿著鐵軌（邊）移動到其他城市（頂點），有兩種方法可以用來搜尋圖：深度優先搜尋（DFS）和廣度優先搜尋（BFS）。它們最終都會到達所有連通的頂點，
深度優先搜尋通過棧來實現，而廣度優先搜尋通過佇列來實現，不同的實現機制導致不同的搜尋方式。

①、深度優先搜尋（DFS）
深度優先搜尋演演算法有如下規則：
規則1：如果可能，存取一個鄰接的未存取頂點，標記它，並將它放入棧中。
規則2：當不能執行規則 1 時，如果棧不為空，就從棧中彈出一個頂點。
規則3：如果不能執行規則 1 和規則 2 時，就完成了整個搜尋過程。

對於上圖，應用深度優先搜尋如下：假設選取 A 頂點為起始點，並且按照字母優先順序進行存取，那麼應用規則 1 ，接下來存取頂點 B，然後標記它，並將它放入棧中；再次應用規則 1，
接下來存取頂點 F，再次應用規則 1，存取頂點 H。我們這時候發現，沒有 H 頂點的鄰接點了，這時候應用規則 2，從棧中彈出 H，這時候回到了頂點 F，但是我們發現 F 也除了 H 也沒有與之鄰接且未存取的頂點了，
那麼再彈出 F，這時候回到頂點 B，同理規則 1 應用不了，應用規則 2，彈出 B，這時候棧中只有頂點 A了，然後 A 還有未存取的鄰接點，所有接下來存取頂點 C，但是 C又是這條線的終點，所以從棧中彈出它，
再次回到 A，接著存取 D,G,I，最後也回到了 A，然後存取 E，但是最後又回到了頂點 A，這時候我們發現 A沒有未存取的鄰接點了，所以也把它彈出棧。現在棧中已無頂點，於是應用規則 3，完成了整個搜尋過程。
深度優先搜尋在於能夠找到與某一頂點鄰接且沒有存取過的頂點。這裡以鄰接矩陣為例，找到頂點所在的行，從第一列開始向後尋找值為1的列；列號是鄰接頂點的號碼，檢查這個頂點是否未存取過，
如果是這樣，那麼這就是要存取的下一個頂點，如果該行沒有頂點既等於1（鄰接）且又是未存取的，那麼與指定點相鄰接的頂點就全部存取過了（後面會用演演算法實現）。

②、廣度優先搜尋（BFS）
深度優先搜尋要儘可能的遠離起始點，而廣度優先搜尋則要儘可能的靠近起始點，它首先存取起始頂點的所有鄰接點，然後再存取較遠的區域，這種搜尋不能用棧實現，而是用佇列實現。
規則1：存取下一個未存取的鄰接點（如果存在），這個頂點必須是當前頂點的鄰接點，標記它，並把它插入到佇列中。
規則2：如果已經沒有未存取的鄰接點而不能執行規則 1 時，那麼從佇列列頭取出一個頂點（如果存在），並使其成為當前頂點。
規則3：如果因為佇列為空而不能執行規則 2，則搜尋結束。
對於上面的圖，應用廣度優先搜尋：以A為起始點，首先存取所有與 A 相鄰的頂點，並在存取的同時將其插入佇列中，現在已經存取了 A,B,C,D和E。這時佇列（從頭到尾）包含 BCDE，
已經沒有未存取的且與頂點 A 鄰接的頂點了，所以從佇列中取出B，尋找與B鄰接的頂點，這時找到F，所以把F插入到佇列中。已經沒有未存取且與B鄰接的頂點了，所以從佇列列頭取出C，它沒有未存取的鄰接點。
因此取出 D 並存取 G，D也沒有未存取的鄰接點了，所以取出E，現在佇列中有 FG，在取出 F，存取 H，然後取出 G，存取 I，現在佇列中有 HI，當取出他們時，發現沒有其它為存取的頂點了，這時佇列為空，搜尋結束。
 */